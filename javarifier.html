<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>Javarifier</title>
</head>
<body>
<h1>Javarifier: Inference of reference immutability for Javari</h1>

<p>Contents:</p>
<!-- start toc.  do not edit; run html-update-toc instead -->
    <ul>
      <li><a href="#motivation">Motivation: Inferring reference immutability in Java programs</a></li>
      <li><a href="#javarifier-description">Javarifier</a>
        <ul>
          <li><a href="#stubs-description">Inference using existing Javari classes and stubs</a></li>
          <li><a href="#javari-differences">Differences from previous versions of Javari</a></li>
        </ul></li>
      <li><a href="#installation">Installation</a></li>
      <li><a href="#using">Using Javarifier</a>
        <ul>
          <li><a href="#using-classpath">Specifying a classpath</a></li>
          <li><a href="#using-output">Outputting to a file</a></li>
          <li><a href="#using-world">Specifying library jarfiles</a></li>
          <li><a href="#using-stubs">Using stub classes</a></li>
          <li><a href="#using-heuristics">Applying heuristics to exclude fields from the abstract state</a></li>
          <li><a href="#using-debug">Understanding and debugging Javarifier output</a></li>
          <li><a href="#test-suite">Running Javarifier test suite</a></li>
        </ul></li>
      <li><a href="#feedback">Feedback</a>
        <ul>
          <li><a href="#release-notes">Release notes</a></li>
        </ul></li>
    </ul>
<!-- end toc -->



<h2 id="motivation">Motivation: Inferring reference immutability in Java programs</h2>

<p>
Javarifier tells you which variables your program mutates, and which
variables are never used for side effects.
</p>

<p>
Javarifier infers the immutability of every
reference in a Java program,
using the definition of the
<a href="http://pag.csail.mit.edu/javari/">Javari</a> language.
In other words, it converts Java programs and
libraries to Javari.
</p>

<p>
Javarifier annotates <code>.java</code> files
with backward-compatible comments, or annotates <code>.class</code> files
with backward-compatible attributes.
The algorithm for inferring Javari reference immutability is explained
in the paper
<a href="http://www.cs.washington.edu/homes/mernst/pubs/infer-refimmutability-ecoop2008-abstract.html">"Inference
  of reference immutability"</a>, which appeared at ECOOP 2008.
</p>

<p>
Annotating <em>programs</em> aids developers in reasoning about the code
and modifying it without introducing subtle mutation errors.  Annotating
<em>libraries</em> is important because Javari programs use libraries
without Javari annotations often do not typecheck.  Manually determining
the mutability for each (public) parameter and return type is tedious and
error-prone.  Javarifier automatically performs this analysis, and a
<a href="http://types.cs.washington.edu/annotation-file-utilities/">companion
  tool</a> can automatically update your source code.
</p>


<h2 id="javarifier-description">Javarifier</h2>

<p>
Javarifier's input is Java <code>.class</code> files.
Javarifier's output is an
<a href="http://types.cs.washington.edu/annotation-file-utilities/">annotation
file</a>, a textual file format for describing annotations
of Java programs; the input class files are not
modified.  The annotation file can be used by a tool such as the
<a href="http://types.cs.washington.edu/annotation-file-utilities/">annotation
file utilities</a>, which  inserts the annotations into either the
<code>.class</code> files or the corresponding <code>.java</code>
files.  If Javari annotations are inserted into the source code, they can
be checked by the
<a href="http://types.cs.washington.edu/checker-framework">Javari type
checker</a>.
</p>


<h3 id="stubs-description">Inference using existing Javari classes and stubs</h3>

<p>
Javarifier respects all existing Javari annotations in the program classes
it analyzes.  If any type is already annotated as <code>@ReadOnly</code>,
Javarifier uses this annotation to determine the mutability of other types
and does not change the existing <code>@ReadOnly</code> annotation.  This
mechanism is how Javarifier infers annotations on a program that uses libraries
that have already been annotated using stub classes.
</p>


<h3 id="javari-differences">Differences from previous versions of Javari</h3>

<p>
In earlier versions of Javari, methods must be invariant in the mutability
of their parameters and return types.  The newer definition of Javari used
by both Javarifier and the
<a href="http://types.cs.washington.edu/checker-framework">Javari type checker</a>
permits covariant subtyping on parameters and contra-variant subtyping on
return types.
</p>


<h2 id="installation">Installation</h2>

<p> The following instructions assume either a Linux or Windows
command-line environment.  </p>

<p> The current distribution is <code>Javarifier version 0.1.3</code>,
released April 27, 2008.  </p>

<ol>
<li>
  Download
  <a href="http://types.cs.washington.edu/javarifier/javarifier.zip">javarifier.zip</a>.
</li>

<li>
  Unpack the distribution zipfile by running:

  <pre>  unzip javarifier.zip</pre>

</li>

<li>
Add the <tt>javarifier/scripts</tt> directory to your path.

<ul>
<li>
For <b>Unix</b>, add the directory to your PATH environment
variable.
<ul>
<li>
  For sh/bash, add to ~/.bashrc or ~/.bash_profile:
<pre>export PATH=${PATH}:/path/to/javarifier/scripts/</pre>
</li>
<li>
For csh/tcsh, add to ~/.tcshrc or ~/.cshrc or ~/.login:
<pre>setenv PATH=${PATH}:/path/to/javarifier/scripts/</pre>
</li>
</ul>
</li>

<li>
For <b>Windows</b>, add the directory to your
<code>PATH</code> system
variable by going to

<pre> Control Panel -> System -> Advanced -> Environment Variables </pre>

<p>
From there, find the <code> PATH </code> variable under &ldquo;System variables&rdquo;
and append to it the <code>javarifier</code> directory.
</p>
</li>
</ul>
</li>
</ol>


<h2 id="using">Using Javarifier</h2> <p> The following instructions
are for running <code>javarifier</code> on a Linux machine.  The
instructions are the same for Windows, except the tool is
<code>javarifier.bat</code>, and you must use Windows path names
instead of Unix path names.  </p>

<p> The <code>javarifier</code> tool takes as arguments
any number of fully-qualified names of the classes to analyze.
For example: </p>

<pre>javarifier myPackage.myClassOne myPackage.myClassTwo</pre>

To analyze all classes in a package <code>myPackage</code>, run the
following in its parent directory:

<pre>javarifier `find myPackage -type f -name '*.java' | perl -p -e 's/\.java//g; s/\//./g'`</pre>


<h3 id="using-classpath"> Specifying a classpath</h3>

<p>
All of the classes being analyzed must be on the path specified by the
<a href="#using-classpath">-programCPEntries</a> option, which defaults to
$CLASSPATH.
</p>

<p>
If you get an error "couldn't find class: ... (is your soot-class-path set
properly?)", then the problem may be that you did not set
<tt>-programCPEntries</tt>.
</p>

<!--
This isn't necessary any longer, I think:
<p>
(Just using the default <code>$CLASSPATH</code> may not work, because the
JVM may
also load classes from other locations, such as the boot class path.
An example is the classes in <code>jdk/jre/lib/jce.jar</code>.
Therefore, you may need to add such jar files to CLASSPATH, or explicitly
mention them on the javarifier command line
via the <a href="#using-world"><code>-world</code> option</a>.)
</p>
-->

<pre>
javarifier myPackage.myClassTwo -programCPEntries /path/to/classes1:/path/to/classes2
</pre>

<p>
These two examples are identical:
</p>

<pre>
javarifier myPackage.myClassTwo
javarifier myPackage.myClassTwo -programCPEntries $CLASSPATH
</pre>


<h3 id="using-output">Outputting to a file</h3>

<p>
By default, all output, including the results, is printed to standard
out.  To output the results to an <a href="http://types.cs.washington.edu/annotation-file-utilities/">annotation file</a>, use the
<code>-output</code> option, followed by the name of the output file.
Note that Javarifier outputs the results for all classes into a single
file.  For example:
</p>

<pre>javarifier myPackage.myClassOne myPackage.myClassTwo -output myPackage.jaif</pre>


<h3 id="using-world">Specifying library jarfiles</h3>

<p>
The program on which you are running Javarifier may depend on
the JDK and other libraries.

By default, Javarifier assumes that those libraries are on your
CLASSPATH.  For example, it assumes <code>rt.jar</code> is in your
CLASSPATH.  If this is not the case, or if you wish to reference a
different JDK, you may use the <code>-world</code> option, followed by
the classpath of your JDK jarfiles.  For example:
</p>

<pre>javarifier myPackage.myClassOne myPackage.myClassTwo -world /jdk1.7.0/jre/lib/rt.jar:/jdk1.7.0/jre/lib/resources.jar:/jdk1.7.0/jre/lib/all-other-jars.jar</pre>


<h3 id="using-stubs">Using stub classes</h3>

<p>A stub class gives Javari types for an external library.
The <a href="http://types.cs.washington.edu/checker-framework/">Checker
Framework</a> comes with annotated versions of part of the JDK,
which Javarifier uses by default.
</p>

<p>
To inform Javari of additional stub classes (or
fully-annotated Javari classes), use the <code>-stubs</code> argument,
    followed by a classpath  to containing stub classes.  All classes
    found in that classpath will be treated as stub classes.  For
    example:
    <pre><code> javarifier myPackage.myClassOne myPackage.myClassTwo -stubs /path/to/stubs/dir:/path/to/stubs.jar</code></pre>
</p>

<p>
If no stub class is available for a particular
class, then Javarifier assumes that every reference in that class has
<code>@Mutable</code> type.
The <code>-printStubs</code> flag causes Javarifier not to perform
inference, but only to output a list of classes for which stubs are needed.
</p>

<p>If you get the error "Missing stub for class ...",
then your stub library is missing the given class, or you have not
specified the stub library location properly.
</p>

<p>
If you create stub versions of additional classes (whether in the JDK or
other libraries), or if you improve existing libraries by adding
annotations to them, please email them to
<a href="mailto:javarifier-dev@googlegroups.com">javarifier-dev@googlegroups.com</a> so that we
can include them in future releases.
</p>


<h3 id="using-heuristics">Applying heuristics to exclude fields from the abstract state</h3>

<p>
Javarifier implements several heuristics for inferring which fields should
be excluded from the abstract state of an object.  These heuristics may
infer the <code>@Assignable</code>
and <code>@Mutable</code> field annotations, and these annotations
may affect the end results of Javarifier.  To apply these heuristics, use
the <code>-applyHeuristics</code> flag, as follows:
</p>

<pre>javarifier myPackage.myClass -applyHeuristics</pre>


<p>
These heuristics only apply to private, non-static, non-final fields.
The following is a list of all heuristics currently implemented.
</p>

<ul>
  <li> A field that is only written to in the constructor or in the <code>equals()</code> and <code>hashCode()</code> methods is inferred to be <code>@Assignable</code>.
  </li>
  <li> If a class implements the <code>equals()</code> method, any field that
       is not read in the <code>equals()</code> method is inferred to be <code>@Assignable</code>.
  </li>
  <li> A field that is written to in a method that overrides either
       <code>Iterator.next()</code> or <code>Enumeration.nextElement()</code>
       is inferred to be <code>@Assignable</code>.
  </li>
</ul>

<h3 id="using-debug">Understanding and debugging Javarifier output</h3>

<p>
Javarifier may infer some references to be <code>@Mutable</code> that you
believe should be <code>@ReadOnly</code> (or vice versa).  This usually indicates a problem
with your code such as a bug, a missing <code>@Assignable</code> keyword,
or simply that you have misunderstood what your code does.  Sometimes, it
can indicate a bug in Javarifier.
</p>

<p>
To understand why Javarifier inferred a particular type qualifier, you can
enumerate the causes for each qualifier. Use the <code>-dumpCauses</code> flag, as in:
</p>

<pre>javarifier myPackage.myClass -dumpCauses</pre>

<p>
For each annotation, this outputs the shortest-length inference chain.
Variables are written in the same form as outputted by dumpConstraints,
described below.  Rather than giving the raw constraints, this form justifies
the inference with an english explanation.  When the files have been compiled
with debugging symbols, a reference to the source line which caused the
constraint is also given.  Here is the layout of this information:
</p>

<pre>
&lt;Var1&gt;
  <b>ClassName</b>:53: <b>Stmt1</b> 
  Var1 &lt;: Var2 
&lt;Var2&gt;
  <b>ClassName</b>:: <b>MemberName</b> <b>Stmt2</b> 
  Why Var3 and Var4 implies Var2
GUARD:
	&lt;Var3&gt;
	  <b>ClassName</b>:: <b>MemberName</b> <b>Stmt3</b>; 
   Why Var3 is directly apparent
&lt;Var4&gt;
<b>ClassName</b>:: <b>MemberName</b>
Stub
</pre>

<p>
<b>ClassName</b>.java:<b>LineNumber</b>: indicates the class name and line number
information. If line number information, or other debug information
hasn't been generated on compile (-g compiler flag), then this might
not be available, and it might take the form <b>ClassName</b>.java:: <b>methodName</b>.
It is also possible for location information to not be available and not print.
</p>

<p>
"Stub" indicates that the variable is known via a stub declaration.
<b>Stmtn</b> indicates a cursory statement of the form eg. "$e1 = $e2;",
"name.field = $e2", "name[...] = $e3", etc.  $e<b>n</b> indicates a variable
introduced by javarifier.  "GUARD" introduces a sub-chain of causes for the
inferred mutability of the variable.
</p>

<p>
If this is not sufficient to understand the output, then you can also
examine the raw constraints generated by Javarifier during its inference
process.  Use the <code>-dumpConstraints</code> flag, as in:
</p>

<pre>javarifier myPackage.myClass -dumpConstraints</pre>


<p>
The Javarifier constraints are of three types:
</p>

<ul>
  <li>
    A line of the form "U: c1" indicates that the type in c1 must be mutable.
  </li>
  <li>A line of the form "G: c1 -> c2" indicates that if the type in c1 is
    mutable, then the type in c2 must be mutable.
  </li>
  <li>A line of the form "GG: c1 => c2 -> c3" indicates that if the types
    in both c1 and c2 are mutable, then the type in c3 must be mutable.
  </li>
</ul>

<p>
An example of a constraint is
</p>
<pre><code>  U: &lt;Graph.createGraph.this: UNKNOWN LGraph;[] MUTABLE&gt;</code></pre>
<ul>
  <li>
This constraint indicates that the receiver (<code>this</code>) of method
<code>Graph.createGraph</code> must be mutable.
  </li>
  <li>
  The string "LGraph;" is
the JVML format for the Graph class.
  </li>
  <li>
The string "UNKNOWN LGraph;[]" indicates that the mutability of the  Graph
has not yet been determined.  (Due to the unguarded constraint, it will be
mutable in the end.)
  </li>
  <li>
  ctx:m represents the romaybe-context that the constraint is referring
  to; this
  is used for inferring romaybe (see the paper cited below for details).
  Often the constraints are the same across contexts, so
  you might have the following two constraints:
<pre>
  U: &lt;HashEntry.setNext.this: UNKNOWN LHashEntry;[] ctx:m&gt;
  U: &lt;HashEntry.setNext.this: UNKNOWN LHashEntry;[] ctx:r&gt;</code>
</pre>
  </li>
  <li>
    For method receivers, the index -1 is used to refer to the receiver, as
  in the following constraint:
<pre>  U: &lt;&lt;Hashtable: int hashMap(java.lang.Object)&gt;.-1: UNKNOWN LHashtable;[] ctx:m&gt;</pre>
  </li>
  <li>Local variables are named if the classfile has the LocalVariableTypeTable
  attribute.  Otherwise, they are named by their index (e.g., "e0"), as are temporary
  variables, as in:
<pre>  U: &lt;Graph.createGraph.$e0: UNKNOWN LVertex;[] ctx:r&gt;</pre>
  </li>
</ul>


<p>
You may find it helpful to cross-reference between Javarifier constraints
and the Java source code of the classes being analyzed (from the
constraints were generated).
</p>



<p>
For more details about the constraints, see the
paper <a
href="http://www.cs.washington.edu/homes/mernst/pubs/infer-refimmutability-ecoop2008-abstract.html">"Inference
of reference immutability"</a>.
Contact us if you need more help understanding the
constraints.
</p>

<h3 id="test-suite"> Running Javarifier test suite </h3>
<p>
A test suite is included with the release.  To run the test suite, go into the
<code>tests/</code> directory and run <code>make</code>.  The output will
indicate whether the tests passed or failed.
</p>

<h2 id="feedback"> Feedback </h2>

<p>
If you encounter a problem in Javarifier, please submit a bug report via
its <a href="http://code.google.com/p/javarifier/issues/list">issue tracker</a>.
When reporting bugs, please help us to resolve the issue quickly by
including the complete
output of Javarifier, and exact instructions of how to
reproduce a bug (including all necessary input files).
</p>

<p>
Other  questions, comments,  and feature requests
can be sent to <a href="mailto:javarifier-dev@googlegroups.com">javarifier-dev@googlegroups.com</a>.
</p>


<h3 id="release-notes"> Release notes </h3>

<ul>
  <li>
  Version 0.1: (Released November 2, 2007) First release.
  </li>
  <li>
  Version 0.1.1: (Released February 15, 2008) Several bug fixes and
updated documentation.
  </li>
  <li>
  Version 0.1.2: (Released March 7, 2008) Several bug fixes.
Javarifier now works on the Eclipse compiler, which is over
120,000 lines of Java code.
  </li>
  <li>
  Version 0.1.3: (Released April 27, 2008)
  <ul>
    <li> Changed the <code>@RoMaybe</code> qualifier for parametric
    polymorphism over mutability to <code>@PolyRead</code>.
    </li>
    <li> Changed the type rule for inferring <code>@PolyRead</code> to match an
    updated version of <i>Inference of reference mutability</i>, to
    appear in ECOOP '08, which outlines the inference algorithm used by
    Javarifier.
    </li>
    <li> Better documentation of the <code>-dumpConstraints</code>
    command-line option and the format of its output.
    </li>
    <li> Documented the <code>-printStubs</code> command-line option.
    </li>
    <li> Included a test suite for testing Javarifier installation.
    </li>
  </ul>
  </li>
  <li>
  Version ?.?.?: (Released ? ?, ?)
    <ul>
      <li>Implemented and documented the heuristics for excluding fields
           from the abstract state of an object.
           See <a href="#using-heuristics"><code>-applyHeuristics</code></a>.
      </li>
      <li>Refactored the package containing all the Javari annotations from
           <code>checkers.quals</code> to
           <code>checkers.javari.quals</code>
      </li>
      <li>Removed some unnecessary and uninformative messages from output.
      </li>
      <li>Command-line options now start with a double-dash prefix instead
          of a single-dash prefix.  Run "javarifier -h" for a full list.
      </li>
    </ul>
  </li>
</ul>

<hr/>

<p>
Last revised: June 15, 2010
</p>

</body>
</html>

<!--
  This makes Emacs update the "Last revised" paragraph above every time
  you save the file.
-->
<!--
Local Variables:
time-stamp-start: "^Last revised: "
time-stamp-end: "\\.?$"
time-stamp-format: "%:b %:d, %:y"
time-stamp-line-limit: -50
End:
-->

<!--  LocalWords:  utils bashrc tcsh tcshrc cshrc classpath Javarifier Javari
 -->
<!--  LocalWords:  mutabilities subtyping contra javarifier zipfile csh GG im
 -->
<!--  LocalWords:  Javarifier's Tschantz jarfiles programCPEntries LGraph JVML
 -->
<!--  LocalWords:  romaybe LocalVariableTypeTable
 -->
